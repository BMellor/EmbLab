

\documentclass[11pt,fleqn]{book} % Default font size and left-justified equations

\input{structure} % Insert the commands.tex file which contains the majority of the structure behind the template


\usepackage{listings} 
\lstset
{ 
    language=C,
    basicstyle=\ttfamily,
    columns=fullflexible,
    keepspaces=true,
    numbers=none,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
    keywordstyle=\color{blue!80!black},
    stringstyle=\color{red!80!black},
    commentstyle=\color{green!40!black},
    morecomment=[l][\color{magenta!80!black}]{\#}
}

\usepackage{caption}
\captionsetup[figure]{font=small,skip=10pt}

%\usepackage{enumitem}
%\setlist{noitemsep} % or \setlist{noitemsep} to leave space around whole list


%%%%% May be too harsh to prevent paragraph breaks across pages! 
%\interlinepenalty 10000
\widowpenalties 1 10000
\raggedbottom


\newcommand{\ilcode}[1]{
    %\vspace{0.5pt}
    \smallskip
    \colorbox{gray!20!white}{
        \centering
        \parbox{\linewidth-2\fboxsep}{
            \lstinline@#1@
        }
    }
    %\vspace{0.5pt}
}

\newcommand{\code}[3]{
    \begin{figure}[]
        \colorbox{gray!20!white}{
            \parbox{\linewidth-2\fboxsep} {
                \centering 
                \lstinputlisting[language=C]{#1}
            }
        }
        \caption{#2}
        \label{#3}
    \end{figure}
}




\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{float}

\usepackage{silence} % http://ctan.org/pkg/silence
\ErrorFilter{textcomp}{Symbol \textrightarrow not provided}

% Disable paragraph indentation globally since template was indenting some and not others. (looked terrible)
%\setlength{\parindent}{0pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                                                         %%%%
%%%%       Chapter 1: The STM32F072 Discovery and Toolchain                                  %%%%
%%%%                                                                                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\chapterimage{chapter_head_2.png} % Chapter heading image

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                                                         %%%%
%%%%       Chapter 2: Memory-Mapped Peripherals and the GPIO                                 %%%%
%%%%                                                                                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapterimage{chapter_head_2.png} % Chapter heading image
\chapter{Memory-Mapped Peripherals and the GPIO}

\section{Overview}
This section provides an overview of embedded programs, memory-mapped peripherals, and device documentation. The exercises in this lab provide an introduction to memory-mapped register access by guiding the user through configuration of the \textit{GPIO} or general purpose input-output peripheral. The GPIO is one of the fundamental peripherals available and provides access to the physical pins of the STM32F0 device. 

%\section{Explore the Processor Documentation}

\section{Basic Design of an Embedded Program}


The typical layout of an embedded program is very different from most standard programming systems. Figure \ref{programFlow} shows a comparison between devices running an operating system and the operation of many embedded applications. 
Operating systems provide a layer of supervisory code which manages low-level system operations and provides frameworks for resource sharing applications. In these systems, once a user application exits, the operating system takes control and cleans up afterward. In contrast, many embedded applications execute directly on the processor core, with no operating system to launch or clean up after applications exit. This style of development is called ``bare-metal'' programming. 

Near the beginning of every STM32F0 binary executable, there is a jump to a small region of code called the \textit{Reset Vector}. This reset vector is always executed directly after a hardware reset and ensures that the stack, heap, and processor clock are initialized to basic settings, allowing more complex code to operate.

Most of the initialization code is not within the reset vector itself but is scattered throughout the support files that ST Microelectronics and the MDK:ARM toolchain provide. The HAL library is typically used to perform less-critical initialization steps such as clock speed configuration at the beginning of the user's application. 

% PASSIVE VOICE, REVISE
After initialization, the startup code calls the \texttt{main()} function within the user's application. Typically, embedded programs begin by configuring hardware peripherals they require and then enter into an infinite loop containing the majority of the application. This endless loop is required since the main function of an embedded program should never return. Unlike a machine with an operating system, there is nothing to catch the processor's execution after the main program exits. This means that the behavior of the processor after returning is undefined and could range from resetting the device to executing random data.

\begin{figure}[]
    \centering\includegraphics[width=.75\textwidth]{programFlow}
    \caption{Comparison of operating-system and bare-metal systems. }
    \label{programFlow}
\end{figure}


\section{Controlling Device Peripherals}

Open the template code provided with this lab. (shown in Figure \ref{blinky}) This simple program repeatedly toggles pins on the STM32F0 using the GPIO hardware abstraction library drivers. This results in a pattern of alternating flashes as the pins used, connect to LEDs on the STM32F072 Discovery board. 
%\code{./Files/blinky.c}
\code{./Files/blinky.c}{Example ``blinky'' program.}{blinky}

This example program begins by initializing the HAL library and system clock. Then, it initializes the GPIO peripheral controlling the desired pins and enters an infinite \texttt{while} loop. Although many of the function calls in this example program are relatively straightforward to understand, it is important to consider how the HAL library functions modify the physical peripherals of the STM32F0 device.

\subsection{Memory-Mapped Peripherals on the STM32F0}

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{peripherals}
    \caption{Peripheral block diagram for the STM32F0 devices}
    \label{peripherals}
\end{figure}

The STM32F0 processors, as shown by the system block diagram in figure \ref{peripherals}, contain an large number of peripherals with complex interconnections. Luckily, the toolchain hides most of the complicated hardware-level implementation from the end user.

However, how does the processor interact with the hardware surrounding it. There are multiple methods that an engineer can choose when designing a processor core. One of these is to develop the machine language interface so that the processor directly understands instructions to manipulate the surrounding hardware. This method seems straightforward but has the disadvantage of increasing the size and complexity of the instruction decoder hardware. Likewise, if the processor has a significant number of peripherals, the resulting instruction set becomes enormous. 

Most embedded processors have instruction sets that are relatively simple and perform a limited number of tasks. Usually, these tasks/instructions primarily involve arithmetic operations and moving data around the system's memory.

% PASSIVE VOICE
Because of this limitation, one common way of controlling system hardware is to designate regions of memory as \textit{peripheral registers}. When an application writes to the memory address of one of these registers, the memory bus controller recognizes the address as belonging to a specific peripheral. It then routes the data to the appropriate control circuitry for that peripheral instead of system memory. Because these hardware registers are mapped into the system's memory address space, the processor simply considers them as conventional variables. 

Figure \ref{memoryTable} shows a simplified memory map for a STM32F0 processor. Although the STM32F0 devices have only a few kilobytes of combined physical memory, program storage, and mapped peripheral registers, they have a full 32-bit (4GB) address space. Because of this, huge blocks of unimplemented addresses separate each functional region of the address space (program storage, physical memory, and peripheral registers). These gaps in the address space ensure that each type of memory has a unique-bit-pattern and provides for future expansion when developing new chips. 

\begin{figure}[]
    \centering\includegraphics[width=0.25\textwidth]{memoryTable}
    \caption{Simplified memory table for STM32F0 devices.}
    \label{memoryTable}
\end{figure}


\subsection{Differences Between ARM-Core and Device Peripherals}

One unique feature of all ARM chips is that the processor core is developed separately from the rest of the device. ARM Ltd. develops the Cortex processors and licenses the designs to hardware manufacturers to implement into real systems. 

%PASSIVE VOICE
Since the processor core is developed separately, it contains its own set of peripherals. These peripherals have a much closer relationship to the operation of the processor and involve actions that directly manipulate the flow of instruction execution. Examples of these include hardware interrupts and program debugging. Because core peripherals are physically separate from the others within the device, they are memory mapped within a separate region. However, the biggest difference to system programmers is that these peripherals are documented separately from the others.

\subsection{Device Datasheets and Manuals}

Efficiently searching datasheets and manuals is one of the most important skills that an embedded engineer can develop. This trait is important because the sheer amount of information required to understand the operation of many embedded devices completely is staggering. 
Engineers who can rapidly search for information within device documentation do not need to memorize operation details. Likewise, it becomes easier to work with an unknown device. 

Four files provide the documentation for the exercises in these labs. You can download these from the following links. However, it is always a good idea to know how to find them on a manufacturers website.

\begin{enumerate}
    \item \href{http://www.st.com/content/ccc/resource/technical/document/datasheet/cd/46/43/83/22/d3/40/c8/DM00090510.pdf/files/DM00090510.pdf/jcr:content/translations/en.DM00090510.pdf}{\textbf{(STM32F072RBT6 Datasheet) DM00090510.pdf}}
    \begin{itemize}
        % REVISE
        \item The chip datasheet provides device-specific details for the processor used. This includes pin connections for available chip packages and a list of available peripherals.
    \end{itemize}
    \item
    \href{http://www.st.com/content/ccc/resource/technical/document/programming_manual/fc/90/c7/17/a1/44/43/89/DM00051352.pdf/files/DM00051352.pdf/jcr:content/translations/en.DM00051352.pdf}{\textbf{(Programming \& Core Manual) DM00051352.pdf}}
    \begin{itemize}
        \item The core programming manual gives us information on the ARM-core peripherals as well as the assembly instruction set. It is generic to all of the processors within the STM32F0 family.
    \end{itemize}
    \item
    \href{http://www.st.com/content/ccc/resource/technical/document/reference_manual/c2/f8/8a/f2/18/e6/43/96/DM00031936.pdf/files/DM00031936.pdf/jcr:content/translations/en.DM00031936.pdf}{\textbf{(Peripheral Manual) DM00031936.pdf}}
    \begin{itemize}
        \item The peripheral reference manual contains detailed information on all peripherals that can be made available within an STM32F0 device. However, not all STM32F0 devices contain every peripheral! The chip datasheet is required to determine which peripherals are available for use.
    \end{itemize}
    \item 
    \href{http://www.st.com/content/ccc/resource/technical/document/user_manual/3b/8d/46/57/b7/a9/49/b4/DM00099401.pdf/files/DM00099401.pdf/jcr:content/translations/en.DM00099401.pdf}{\textbf{(Discovery Board Manual) DM00099401.pdf}}
    \begin{itemize}
        \item The Discovery board manual contains schematics and tables, showing the onboard devices and connectors attached to the STM32F0. The Discovery board silkscreen also documents many device connections. 
    \end{itemize}
\end{enumerate}

\begin{warning}
    These manuals are large! Do not expect to read them fully; there is simply too much information presented. For example, the peripheral reference manual contains over 1000 pages of detailed descriptions about each peripherals operation and configuration.
\end{warning}

\section{Using Peripheral Control Registers}

\subsection{The General Purpose Input-Output Peripheral (GPIO)}

The GPIO is one of the most fundamental peripherals within the STM32F0. Although it is one of the simplest peripherals, it is still surprisingly complex and very powerful.

% PASSIVE VOICE
Open the STM32F0 peripheral reference manual to page 156; this should be the heading ``General-purpose I/Os (GPIO).'' The reference manual is sectioned by bookmark links, if the PDF viewer used can show these (see Figure \ref{bookmarks}) they can be used to navigate to desired sections quickly.

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{bookmarks}
    \caption{Navigation bookmarks in the peripheral reference manual.}
    \label{bookmarks}
\end{figure}

Each section of the reference manual is organized such that it first introduces the available features and modes of the peripheral. Afterward, it explains in detail the operation of the different modes,  including graphs, figures, and tables showing characteristics of the peripheral's operation. Finally, it provides detailed explanations of each user-accessible control register that configures the peripheral.

% REVISE
To understand the GPIO control registers, it is helpful to discuss the different modes it can operate in. Go back to page 156 in the reference manual (beginning of GPIO section) and look through the information on that page.

The \textit{GPIO main features} section indicates that a GPIO pin can have the following modes:

\begin{itemize}
    \item Output Configuration
    \begin{itemize}
        \item Push-Pull -- Pin is pushed to Vcc when logic `1', pulled to GND when logic `0.'
        \item Open-Drain -- Pin can only be pulled to GND when logic `0', floats when logic `1.'
    \end{itemize}
    \item Digital Input Configuration
    \begin{itemize}
        \item Floating -- Pin has high-impedance, voltage ``floats'' unless externally pulled to a state.
        \item Internal Pull-Up/Down -- Pin has internal ``resistor'' to Vcc or GND.
    \end{itemize}
    \item Analog Input Configuration
    \begin{itemize}
        \item Pin is connected to the system analog peripherals instead of a digital comparator.
    \end{itemize}
    \item Alternate Function Configuration
    \begin{itemize}
        \item Pin is connected to a selection of internal peripherals. These directly control the pin operation.
    \end{itemize}
\end{itemize} 

Additionally, there are other features such as configurable speed, register locking, bit-set-reset and more. This lab section only considers two basic configurations: push-pull output and floating input.

% REVISE
Begin by examining the configuration registers within the GPIO peripheral. Beginning on page 165, the manual starts with the most important register of them all. 

\subsubsection{GPIO Port Mode Register (GPIOx\_MODER)}

The port mode is the most important register in the GPIO peripheral. Without configuring this register, it is impossible to use GPIO pins as anything aside from digital inputs. Examining the register map in the manual shows a table of 16 cells titled ``MODER0[1:0]'' through ``MODER15[1:0]''. Notice that above these cells are numbers ranging from 0-31 and below are cells with ``rw'' in them. Breaking these down gives the following explanations: 

\begin{itemize}
    \item The STM32F0 processors have multiple GPIO peripherals known as \textit{ports}, these are named in the following manner: GPIOA, GPIOB ... GPIOx. Within a GPIO port, there can be up to 16 pins; these pins are named in the following manner: PA0 (GPIOA, Pin 0) ... PA15 (GPIOA, Pin 15), PB0 (GPIOB, Pin 0) ... etc.
    % PASSIVE VOICE, REVISE
    \item STM32F0 devices do not recognize inputs/outputs on a chip by physical pin numbering. The reason for this is because different chip packages have differing numbers of pins, and the pin ordering between these is inconsistent. GPIO pins are instead labeled with a port name (PA0 for example) which describes where to go to configure it. Within the chip datasheet, there is a table mapping GPIO pin names to physical pin numbers on the specific chip package used.
    \item Since there can be up to 16 pins in a GPIO bank, there are 16 ``MODER'' cells (pairs of bits) within the mode register. Because GPIO pins start counting from 0, the 16 pins are numbered 0 through 15.
    % PASSIVE VOICE, REVISE
    \item The number above each cell in the register map indicates the bit number within the register. Each ``MODER'' cell consists of 2 bits; this is because there are four main modes that pins can be configured into. A description of the different modes, as well as the bit patterns, used to select them, are directly below the register map.
    To choose one of these modes, the bits within the correct ``MODER,'' cell for the desired pin must be set to the corresponding bit pattern.
    \item The ``rw'' below each of the cells in the register map indicate that the corresponding bit can be both read and written. Sometimes individual bits or entire registers are read-only or write-only.
\end{itemize}

\begin{example}[Setting a Pin to Output Mode]
    The following steps configure pin PB3 to be an output. Figure \ref{modeReg} outlines these using the GPIOx\_MODER register map in the peripheral reference manual.
    \begin{enumerate}
        \item The name PB3 indicates that the pin belongs to the GPIOB peripheral and is the fourth pin in the control register. (pin numbering begins at zero)
        \item The fourth cell in the GPIOx\_MODER register map is labeled ``MODER3'' and contains bits 6-7.
        \item Examine the bit patterns listed below the register map. One of these \{\texttt{01}\} corresponds to ``General purpose output mode.''
        % PASSIVE VOICE
        \item The output mode bit pattern indicates that for the two configuration bits, the lower should be set to `1' and the upper should be cleared to `0'.
        \item Since bits 6-7 in the GPIOx\_MODER register control pin PB3, setting bit 6 and clearing bit 7 will configure the pin to output mode. 
    \end{enumerate}  
\end{example}

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{modeReg}
    \caption{Configuring the mode register to set a pin to output mode.}
    \label{modeReg}
\end{figure}

\subsubsection{GPIO port output type register (GPIOx\_OTYPER)}
% PASSIVE VOICE
This register selects what type of output mode you want for each pin configured as an output. For pins that aren't configured in output mode, the bits in this register have no effect. Since there are only two possible modes, there is only one bit per pin defined. The rest of the register is ``reserved'' and you shouldn't try to write anything there.

\subsubsection{GPIO port output speed register (GPIOx\_OSPEEDR)}
% PASSIVE 
One of the major selling points of ARM processors is that they typically use very low power. One way that they manage to reach such low power consumption is because most peripherals are either disabled and/or slowed-down by default. GPIO pins on an STM32F0 can be configured into three different speed modes, with the slowest using the least amount of power and the fastest using the most.

% REVISE
You might notice that the reference manual does not tell you how fast each speed mode operates. This is because it is dependent on the specific STM32F0 processor used. You can find out the different speed modes by looking in the device datasheet, section 6.3.14 (Electrical characteristics \textrightarrow Operating conditions \textrightarrow I/O port characteristics \textrightarrow I/O AC characteristics).

\subsubsection{GPIO port pull-up/pull-down register (GPIOx\_PUPDR)}
This register connects internal pull-up or pull-down ``resistors'' to a pin. These resistors are actually transistors that are not completely turned on but will leak enough current to act as a high-value resistor. (>100kOhm usually) Typically the internal pull resistors are only used for input modes.

% REVISE
One thing to notice with the option bits for this register is that one of the bit patterns is reserved. This means that you should never set the bit-pairs in the register into that state, although undefined it is possible that it could turn on both the pull-up and the pull-down resistors and waste power.

\subsubsection{GPIO port input data register (GPIOx\_IDR)}
All of the registers that we've seen so far have been read-write, we can both read and write to them to modify pin configuration. If you look at the register map, you'll find that all the bits in this register are read-only.

% PASSIVE
The data input register always shows the logical state of each pin in the GPIO port. If the pin is an input, then the matching bit will show whatever logical state the outside world is driving that pin. If a pin is configured as an output, then it will show whatever logical state you have set that pin to be with the output register.

\subsubsection{GPIO port output data register (GPIOx\_ODR)}
This register sets the logical state of pins configured to be outputs. If you write a `0' to a bit in this register, then its matching pin will be pulled low. If you write a `1' to the bit, then the pin will be driven high.

\subsubsection{GPIO port bit set/reset register (GPIOx\_BSRR)}
This register is write-only. The reason why is that it's a shortcut to set and clear bits in the output register. Typically you can't just overwrite an entire register with a new value for a single bit because there are other bits that you don't want to overwrite. You first have to read the register value, perform a bitwise operation, so the bit you want is modified and then write it back.

The bit set/reset register allows for much faster modification of the output register because you never have to read or worry about other bits except the one you want to modify. You can simply overwrite the entire register; it will only modify the output register on the bits you have set.The lower half of this register sets bits in the output, the upper half clears/resets them.

\subsubsection{GPIO port configuration lock register (GPIOx\_LCKR)}
% REVISE
The configuration lock register locks the other configuration registers for the associated pin. It's intended to prevent a malfunctioning program from accidentally changing a pin into an unwanted mode. Once the lock is activated, you can't edit the lock register unless you first go through a timed sequence of writes on a specific bit. This is an advanced feature that you typically won't use often.

\subsubsection{GPIO alternate function low/high registers (GPIOx\_AFRL/GPIOx\_AFRH)}
% PASSIVE, REVISE
Looking at these registers you'll notice that every pin has four bits for configuration. This means that there are two 32-bit registers (AFRL \& AFRH) needed to configure alternate functions for all 16 pins. The alternate functions that each pin can be connected to depends on the specific processor and pin. There is a table in the device specific datasheet which lists the possible alternate functions for each pin, as well as what number each function has.

We will be using alternate functions in the next lab to connect GPIO pins to timer peripherals.

\subsubsection{GPIO port bit reset register (GPIOx\_BRR)}
This last control register in the GPIO peripheral is very similar to the bit set/reset register. Although you can clear bits using the bit set/reset register, all of the clearing bits are in the upper half of the register. This reset-only register is essentially a copy but has the clearing bits in the lower half. If you look at the mapping between bits in this and the bit set/reset register and their effect on the output register you might see why some people wanted the clear bits also in the low positions.

\newpage
\begin{exercise}[Finding Configuration Bits]
    \label{ex1}
    Using the peripheral reference manual, list the bit numbers and whether each bit should be set or cleared in the following GPIO registers to configure the pins \textit{PC8} and \textit{PC9} to the following state:
    \begin{itemize}
        \item \textbf{GPIOx\_MODER} -- General purpose output mode
        \item \textbf{GPIOx\_OTYPER} -- Output push-pull
        \item \textbf{GPIOx\_OSPEEDR} -- Low speed 
        \item \textbf{GPIOx\_PUPDR} -- No pull-up, pull-down 
    \end{itemize}
\end{exercise}

\subsection{Finding Register Definitions in ST's Header Files}

Take a look at the following line of code; you'll notice that I'm casting a hexadecimal memory address to a pointer, dereferencing that pointer and writing data to the memory location that the dereferenced pointer references. This code accesses the GPIOC mode register (GPIOC\_MODER) and configures pins PC8 and PC9 to output mode.

\ilcode{*((volatile uint32\_t*) 0x48000800) = 0x50000;}%{0.25em}
\smallskip
%\texttt{*((volatile uint32\_t*) 0x48000800) = 0x50000;}\\

% REVISE
While pointers and memory addresses are technically the only method available to interact with peripheral registers, the pointer cast and dereference syntax is not particularly convenient.

%REVISE
Although most embedded code simplifies into statements like this, we do not typically have to look up memory addresses and make/dereference pointers as previously shown. This is because ST provides header files which name and organize hardware registers into structures that are reasonable to deal with. Using these header files, the pointer code above becomes much simpler as shown below.

\ilcode{GPIOC->MODER = 0x50000;}%{0.25em}
\smallskip

%\texttt{GPIOC->MODER = 0x50000;}\\

% PASSIVE
Looking back to the GPIO register pages in the peripheral reference manual, you will notice that each register has been given a short abbreviated name. Likewise you will see that the bits within the registers are also named. Figure \ref{regName} shows the highlighted names for the GPIO mode register. 

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{regName}
    \caption{GPIO mode register with keyword names circled}
    \label{regName}
\end{figure}

% PASSIVE
A good question to ask at this point would be where the names for registers are defined, and how they are accessed from a C program? The answer is within the \textit{CMSIS Cortex-M0 Device Peripheral Access Layer Header Files} also known as ``stm32f0xx.h'' and its derivatives. Originally all peripheral information for the entire STM32F0 line was defined in ``stm32f0xx.h''. However, in recent versions of the HAL, ST Microelectronics has split the information for each device sub-family into separate files. 

Open a {\textmu}Vision project and expand the project hierarchy under ``main.c.'' If {\textmu}Vision doesn't show any included headers after expanding the hierarchy, compile the project, and it should update after parsing the code dependencies. Within the list of these files, you should see the both ``stm32f0xx.h'' and ``stm32f072xb.h.''  Alternatively, you can locate these files manually by searching for them within the project directory under: "Drivers\textbackslash CMSIS\textbackslash Device\textbackslash ST\textbackslash STM32F0xx\textbackslash Include." 

\subsubsection{Searching the ``stm32f072xb.h'' File}

Open the ``stm32f072xb.h.'' file and look for the introductory header comment which gives a summary of the functionality provided. Since many IDE's like to collapse large sections of commented text you may need to expand the comment with the small ``+'' icon near the line numbers. Because the "stm32f072xb.h" file is large (>10000 lines) you will need to use the text search features of the IDE to navigate. In order to do this, we need to get familiar with how the file organizes peripherals and their registers

Move down to line 390; you will notice that this is a typedef for a C-structure representing a GPIO peripheral. This structure type creates a neat package for named pointers to each of the control registers a GPIO peripheral has. Because this code is a c-type definition, the system can create named copies of the structure for every GPIO peripheral in the device. The "stm32f072xb.h" file also defines the contents of the register pointers in each peripheral structure, so we don't need to deal directly with memory addresses.

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{struct}
    \caption{GPIO structure definition}
    \label{struct}
\end{figure}

Returning to the top of the header file, open {\textmu}Vision's text search feature by selecting: \textbf{Edit Menu \textrightarrow Find}. Type ``GPIO'' into the search box and hit the find button. More likely than not, {\textmu}Vision's took you directly to line 390 again. Typically, searching on a guess of the peripheral name is the easiest way to start finding the documentation you'll need. Now, open the text search window again and search for the structure name defining the GPIO peripheral, you'll find it right after the closing curly-brace at the end of the GPIO structure code. ("GPIO\_TypeDef")

Searching on the name of the GPIO structure likely took you to line 785. Here we can see the multiple named copies of the GPIO structure, one for each of the physical GPIO peripherals within the STM32F0 chip. These define statements show the actual name you will use to access the structure for that peripheral.

Returning again to the structure definition, (line 390) try searching on one of the register names it defines. If you searched on the MODER register, you will find that eclipse took you to line 6499 where a list of defines gives names to each of the bits in the register. For simple peripherals like the GPIO, we typically won't use the bit names since their purpose is fairly straightforward and all have similar functions (just on different pins). For more complex peripherals the bit names often tell you their function, we'll see an example of this later.

\begin{exercise}[Accessing GPIO Registers]
    \label{ex2}
    Using the structures in the \textit{stm32f072xb.h} file, document how you would access the following registers for the \textit{GPIOC} peripheral in code.
\begin{itemize}
    \item GPIOx\_MODER
    \item GPIOx\_OTYPER
    \item GPIOx\_OSPEEDR
    \item GPIOx\_PUPDR
\end{itemize}
\end{exercise}

\subsection{Bitwise Operations on Peripheral Registers}

This lab assumes that you have had prior experience with \textit{bitwise} logic operations. Because of this, we'll just have a rapid overview of common tasks. Bitwise logic allows us to manipulate portions of a register without overwriting the rest.

\subsubsection{Setting bits}
To set bits in a register, bitwise-OR its value with a bitmask. Any bits set in the bitmask will be applied to the register's value. The bitwise-OR operator is a single vertical-pipe character `|.'

\ilcode{GPIOC->MODER |= 0b00001000;    // Sets the 3rd bit}%{0em}

\subsubsection{Clearing bits}
% PASSIVE
To clear bits in a register, bitwise-AND its value with a bitwise-Inverted bitmask. Any bits set in the bitmask will be cleared from the register's value. The bitwise-AND operator is a single ampersand character `\&', the bitwise-Invert is the tilde character `\textasciitilde.'

\ilcode{GPIOC->MODER \&= ~(0b00001000);    // Clears the 3rd bit}%{0em}

\subsubsection{Inverting/Toggling bits}
Although there is a bitwise-Invert operator `\textasciitilde' it inverts every bit in the target. To selectively invert a few bits in a register, bitwise-XOR its value with a bitmask. Any bits set in the bitmask will cause the matching bit in the register's value to be inverted. The bitwise-XOR operator is a single caret character `\textasciicircum.'

\ilcode{GPIOC->MODER ^= 0b00001000;    // Inverts the 3rd bit}%{0em}

\begin{warning}
    % PASSIVE
    Note that {\textmu}Vision does \textbf{not} allow binary constants with the ``\texttt{0b}'' prefix. The binary constants shown here are used only for clarity. Within the actual code, hexadecimal constants with the ``\texttt{0x}'' prefix are typically used when explicit values are required.  
\end{warning}

\subsubsection{Building Bitmasks Easily}

Typically building bitmasks using binary or hexadecimal constants makes code difficult to read. There are a number of ways to improve readability, one of which is to use shifted constants. The C compiler is very good at simplifying mathematical expressions that result in a constant value. We can use this to our advantage to ``build'' a bitmask out of multiple statements. The examples in figure \ref{bitwise} build bitmasks by shifting the decimal value `1' (a single binary bit at the lowest position) to the bit position we want to modify.

\code{./files/bitops.c}{Common bitwise operations}{bitwise}

%\colorbox{gray!20!white}{
%    \centering
%    \begin{minipage}{\linewidth}
%        \lstinline@GPIOC->MODER |= (1 << 3);    // Sets the 3rd bit in the GPIOC\_MODER register@ \\
%        
%        \lstinline@GPIOC->MODER |= (1 << 3) | (1 << 5);    // Sets the 3rd and 5th bits in the GPIOC\_MODER register@ \\

%        \lstinline@GPIOC->MODER \&= ~((1 << 3) | (1 << 5));    // Clears the 3rd and 5th bits in the GPIOC\_MODER register@
%    \end{minipage}
%}


%\texttt{GPIOC->MODER |= (1 <{}< 3);    // Sets the 3rd bit in the GPIOC\_MODER register} \\

%\texttt{GPIOC->MODER |= (1 <{}< 3) | (1 <{}< 5);    // Sets the 3rd and 5th bits in the GPIOC\_MODER register}\\

%\texttt{GPIOC->MODER \&= \textasciitilde((1 <{}< 3) | (1 <{}< 5));    // Clears the 3rd and 5th bits in the GPIOC\_MODER register}\\

\subsubsection{Reading the State of a Bit}

Many of the hardware registers within the STM32F0 contain status bits. These indicate events that have occurred within the peripheral, or the current state of device inputs. An example of a register used for this purpose is the GPIO input data register. (IDR)

% PASSIVE
When comparing a register against a constant value, all bits within the register are considered, including those that may have no relation to what is being checked. Because of this, in many cases, it is desirable to separate and check the status of a single bit within a register. Fortunately, individual bits can be isolated using a bitmask and the bitwise AND operation. 

\begin{example}[Checking Specific Bits] 
% PASSIVE
In the first code example below, the first constant represents a register value and the second a bitmask selecting the bit(s) to examine. To isolate a specific bit from a register, set the matching bit at the same position within the bitmask. When bitwise AND'ed together, the result will be zero if the checked bit was zero, and non-zero if the checked bit was set. 

\ilcode{0b01001101 \& 0b01000000 = 0b01000000  // Bitmask isolates bit 6}

\ilcode{if(GPIOC->IDR \& 0x40)\{...\} // Triggers if bit 6 is set }
\smallskip
\end{example}

\newpage
\begin{exercise}[Initializing the GPIO pins]
    \label{ex3}
    Create a new {\textmu}Vision project and replace the \textit{main.c} file with the lab provided template code. This code uses the HAL library to flash the green and orange LEDs. 
    
    Your task is to make incremental changes from the HAL library calls to bitwise operations on peripheral registers. Using the bit numbers and registers from exercises \ref{ex1}-\ref{ex2}, initialize the GPIO pins to the indicated mode and parameters. 
    \begin{itemize}
        \item Remove the \texttt{GPIO\_InitTypeDef} struct and all \texttt{HAL\_GPIO\_Init()} function calls.
        \item Make sure to reference the correct GPIO peripheral indicated by the pin name. 
        \item The green and orange LED pins (PC8 \& PC9) should be configured to: output mode, push-pull type, low speed, and no pull-up/down resistors.
    \end{itemize}

    \noindent Compile and test your changes to the program. If initialized properly, the application should continue to operate as it did originally. 
\end{exercise}

\begin{exercise}[Controlling the GPIO pins] 
    \label{ex4}
     General purpose output pins are controlled by modifying the \textit{ODR}, \textit{BSRR}, and \textit{BRR} registers. Exchange the HAL library calls with bitwise operations and register access.
    \begin{itemize}
        \item Set one pin logic high and the other to low before entering the endless loop.
        \begin{itemize}
            \item Remove the \texttt{HAL\_GPIO\_WritePin()} function call.
            \item Use either the \textit{ODR} or \textit{BSRR} register.  
        \end{itemize}
        \item Toggle both pin output states within the endless loop.
        \begin{itemize}
            \item Remove the \texttt{HAL\_GPIO\_TogglePin()} function call.
            \item Use either the \textit{ODR} or \textit{BSRR} register. 
        \end{itemize}
    \end{itemize}

    \noindent Leave the HAL delay function within the loop. Otherwise, the LEDs will toggle too rapidly to see. Feel free to change the duration to reasonable values.
\end{exercise}
\subsection{Enabling the System Clock to Device Peripherals}

Just as each GPIO pin has multiple speed settings to conserve power, by default most peripherals in the STM32F0 have their clock signals disabled. Since synchronous circuits don't operate without a clock signal, they are essentially "turned-off." In this state they consume significantly less power than they would sitting idle, but you can't read or write any of their registers.

% PASSIVE
The STM32F0's have a dedicated peripheral called the \textit{Reset and Clock Control} (RCC) which enables or disables clock signals around the chip. To enable a clock for a peripheral, we'll have to find the proper RCC enable register. Search the stm32f072xb.h file for ``RCC'', you will find a few of matches within interrupt definition code but keep continuing until you find the ``RCC\_TypeDef'' definition. Within this structure, you can see that three of the registers are labeled as ``peripheral clock registers.''


\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{rccStruct}
    \caption{RCC structure with peripheral clock enable registers highlighted}
    \label{rccStruct}
\end{figure}

% PASSIVE, REVISE
These three registers control the clock signals to all other peripherals, except for those in the ARM-core itself. The peripherals they control are organized by what system communications bus they are connected to. Some high-speed peripherals such as memory control, are connected directly to the \textit{Advanced High-performance Bus} (AHB). However, most peripherals are connected to one of two \textit{Advanced Peripheral Busses} (APB).

% PASSIVE
On the STM32F0, the GPIO peripherals are located on the AHB bus. However, in other architectures and brands, they may be located on the APB.

\begin{example}[Enabling a Peripheral Clock in the RCC]
    The following enables the peripheral clock for the GPIOB peripheral. Notice that a defined bit name was used instead of a simple bitmask. In many cases using these definitions results in clearer code.

    \ilcode{RCC->APB1ENR |= RCC\_APB1ENR\_TIM2EN;    // Enable peripheral clock to TIMER2}
    \smallskip
    %\texttt{RCC->AHBENR |= RCC\_AHBENR\_GPIOAEN;    // Enable peripheral clock to GPIOC}
\end{example}

\begin{exercise}[Enabling the GPIO Peripheral Clock] Before any peripheral can be used, its system clock must enabled. The code enabling the clock to a peripheral must be located before any of the peripherals registers are accessed. 
    \label{ex5}
    \begin{itemize}
        \item Remove the \texttt{\_\_HAL\_RCC\_GPIOC\_CLK\_ENABLE()} HAL library macro.
        \item Use the stm32f072xb.h header file to determine the register that enables the GPIOC peripheral clock.
        \item Set the appropriate bit using bitwise operations and either a bitmask or defined bit name. 
    \end{itemize}
\end{exercise}

\subsection{Slowing the System Down}
Even though the STM32F072 operates at a far slower clock rate than a conventional computer, it executes instructions fast enough that a simple pin toggling loop will flash the LED's faster than the human eye can see. Because of this, we'll have to introduce our own methods of adding delay into the program..

\subsubsection{Delay Loops}
% PASSIVE, REVISE
One simple (and very inefficient) way of adding delay into a program is to make the processor do lots of useless work in a \textit{busy loop}. A typical method of implementing a busy loop is to repeatedly increment a number until a limit is reached.

Unfortunately, compilers are pretty good at detecting and removing ``useless'' code that doesn't seem to be used anywhere else in the program. To help force the compiler to leave a delay loop alone, you will need to tag the loop variable as \textit{volatile}. One of the uses of the volatile keyword is to tell the system that the tagged variable has desired side-effects that the compiler may not see. Without this keyword, the compiler will optimize and remove structures such as delay loops.

%\colorbox{gray!20!white}{
%    \centering
%    \begin{minipage}{\linewidth}
%        \lstinline@volatile int i;@ \\
%        \lstinline@for(i=0; i < 100000; i++)\{\}@ 
%    \end{minipage}
%}

\smallskip
\colorbox{gray!20!white}{
    \centering
    \parbox{\linewidth-2\fboxsep}{
        \lstinline@volatile int i;@ \\
        \lstinline@for(i=0; i < 100000; i++)\{\}@ 
    }
}
\smallskip

In practice, delay loops are one of the most least-effective ways to introduce delay into a program. If possible, avoid using delay loops if hardware timing capabilities are available. 

\begin{warning}
    Always use the HAL library delay functions when blocking delays are required. Do not use busy-loops when timing hardware is available.
\end{warning}

\subsubsection{Hardware SysTick Delay}

% PASSIVE
The \textit{SysTick} timer peripheral is a device which raises a system signal at a configurable periodic rate. Because the time duration between these signals is known, the SysTick is often used as an application heartbeat. The HAL library uses the SysTick to trigger periodic tasks such as updating a global system time variable. 

As seen in the ``blinky'' example, the infinite loop calls the \texttt{HAL\_Delay()} function. This function is one of the delay mechanisms in the HAL library and halts the execution of a program by the number of milliseconds given as an argument. 

\ilcode{HAL_Delay(200); // Delay 200ms}
%\smallskip

% PASSIVE
\noindent Although these labs avoid using the HAL library resources, it is encouraged that you use the HAL delay function. The SysTick timer is automatically initialized during clock speed configuration and makes it easier to use the preexisting delay functionality. 



%\section{Hello World: Writing Basic I/O Code}
%\section{Section Activity: Writing Basic I/O Code}
\section{Lab Assignment: Writing Basic I/O Code}

These exercises explore two basic operations of the GPIO: Blinking LEDs and reading the state of a pushbutton.
After completing these tasks, make sure to show the lab assistant! Most of your points for this lab will come from demonstrating that your code works. 
\begin{warning}
As mentioned earlier, \textbf{you will need to write your applications using \textit{only} peripheral register access.} The single exception to this is the \texttt{\textbf{HAL\_Delay()}} function.
\end{warning}

There are multiple ways to approach these exercises. Many lab assignments begin as empty projects, however, it is recommended for this first application that you begin with the provided ``blinky'' example code and make incremental changes from the HAL library calls to bitwise operations on peripheral registers.

% REVISE
The benefit of converting a working example is that it becomes possible to compile and test the application after replacing each line of code. This breaks down the possible sources of error into manageable portions. 

\begin{exercise}[Configuring a GPIO Pin to Output and Blink an LED]
    Complete exercises \ref{ex1} though \ref{ex5} and demonstrate to your TA that the application operates using only register access. 
    
    
    
\end{exercise}

%Your goal in this lab assignment is to recreate the blinking demo using the red and blue LEDs on the Discovery board. 
%
%If beginning with the example ``blinky'' application, the assignment can be broken down into the following steps:
%
%\subsubsection{Converting the HAL Library Calls to Register Access}
%\begin{enumerate}
%    
%    \item Use the RCC to enable the GPIOC peripheral clock.
%    \begin{itemize}
%        \item Remove the \texttt{\_\_HAL\_RCC\_GPIOC\_CLK\_ENABLE()} HAL library macro.
%        \item Use the stm32f072xb.h header file to determine the register that enables the GPIOC peripheral clock.
%        \item Set the appropriate bit using bitwise operations and either a bitmask or defined bit name. 
%    \end{itemize}
%    \item Configure the LED pins to slow-speed, push-pull output mode without pull-up/down resistors.
%    \begin{itemize}
%        \item Remove the \texttt{GPIO\_InitTypeDef} struct and \texttt{HAL\_GPIO\_Init()} function call.
%        \item The green and orange LEDs are on pins PC8 and PC9.
%        \item Set the pins to general-purpose output mode in the MODER register. 
%        \item Set the pins to push-pull output type in the OTYPER register.
%        \item Set the pins to low speed in the OSPEEDR register. 
%        \item Set to no pull-up/down resistors in the PUPDR register. 
%    \end{itemize}
%
%    Each register map in the peripheral reference manual documents the starting state of bits in the register. Although clearing bits that should already be zero is not always necessary, it is good style to ensure that every bit is in a known state.  
%    \medskip
%
%    \item Initialize one pin logic high and the other to low.
%    \begin{itemize}
%        \item Remove the \texttt{HAL\_GPIO\_WritePin()} function call.
%        \item Use either the ODR or BSRR register.  
%    \end{itemize}
%    \item Toggle both pin output states within the endless loop.
%    \begin{itemize}
%        \item Remove the \texttt{HAL\_GPIO\_TogglePin()} function call.
%        \item Use either the ODR or BSRR register. 
%    \end{itemize}
%    \item Leave the HAL delay function within the loop. Otherwise, the LEDs will toggle too rapidly to see. Feel free to change the duration to reasonable values.
%\end{enumerate}


\begin{exercise}[Configuring a GPIO Pin to Input and Reading a Button]
After demonstrating the previous exercise, change your version of the flashing LED program such that the LEDs toggle on a button press instead of a set delay. This can be broken down into the following steps:

\begin{enumerate}
    \item The \textit{USER} button is connected to pin \textit{PA0} on the STM32F0.
    \item Use the RCC to enable the clock to the appropriate GPIO peripheral.
    \item Configure the button pin to input mode with the internal pull-down resistor enabled.
    \begin{itemize}
        \item Set the pin to input mode in the \textit{MODER} register. 
        \item Set the pin to low speed in the \textit{OSPEEDR} register. 
        \item Enable the pull-down resistor in the \textit{PUPDR} register. 
    \end{itemize}
    \item Monitor the button pin input state using the IDR register within the endless program loop.
    \begin{itemize}
        \item Toggle the LED pins when a button press is detected.
    \end{itemize}
\end{enumerate}

% PASSIVE
\noindent Because the application will be waiting for the button press before toggling the LEDs, there is no longer any need for the delay statement each loop iteration. Demonstrate the working adaption to your TA. 
\end{exercise}

\begin{warning}
    Some GPIO peripherals contain pins with system critical functions. For example, GPIOA contains pins PA13 (SWDIO) \& PA14 (SWCLK) which are used by the debugging hardware to communicate with the STM32F0. 
    
    % PASSIVE
    When using GPIO peripherals with special functions, \textbf{do not modify the control bits for these pins!} This includes clearing the entire register to ensure that all unknown bit states are set to a known value. 
    
    If the configuration for PA13 and PA14 is modified, the debugger will no longer be able to program the Discovery board. If this occurs, it can be fixed using the standalone ST-Link utility.
\end{warning}

\end{document}



\documentclass[11pt,fleqn]{book} % Default font size and left-justified equations

\input{structure} % Insert the commands.tex file which contains the majority of the structure behind the template
\usepackage{float}

\usepackage{listings} 
\lstset
{ 
    language=C,
    basicstyle=\ttfamily,
    columns=fullflexible,
    keepspaces=true,
    numbers=none,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
    keywordstyle=\color{blue!80!black},
    stringstyle=\color{red!80!black},
    commentstyle=\color{green!40!black},
    morecomment=[l][\color{magenta!80!black}]{\#}
}

\usepackage{caption}
\captionsetup[figure]{font=small,skip=10pt}

%\usepackage{enumitem}
%\setlist{noitemsep} % or \setlist{noitemsep} to leave space around whole list


%%%%% May be too harsh to prevent paragraph breaks across pages! 
%\interlinepenalty 10000
\widowpenalties 1 10000
\raggedbottom


\newcommand{\ilcode}[1]{
    %\vspace{0.5pt}
    \smallskip
    \colorbox{gray!20!white}{
        \centering
        \parbox{\linewidth-2\fboxsep}{
            \lstinline@#1@
        }
    }
    %\vspace{0.5pt}
}

\newcommand{\code}[3]{
    \begin{figure}[]
        \colorbox{gray!20!white}{
            \parbox{\linewidth-2\fboxsep} {
                \centering 
                \lstinputlisting[language=C]{#1}
            }
        }
        \caption{#2}
        \label{#3}
    \end{figure}
}

\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{float}

\usepackage{silence} % http://ctan.org/pkg/silence
\ErrorFilter{textcomp}{Symbol \textrightarrow not provided}

% Disable paragraph indentation globally since template was indenting some and not others. (looked terrible)
\setlength{\parindent}{0pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                                                         %%%%
%%%%       Chapter 5: Embedded Communications and the USART                                  %%%%
%%%%                                                                                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setcounter{chapter}{4} % Manually adjust chapter counter to number before desired chapter heading

\begin{document}
	
\chapterimage{chapter_head_2.png} % Chapter heading image
\chapter{Embedded Communications and the USART}

\section{Communication Between Systems}
All computing systems regardless of their size and power, are essentially useless if they don't have some way to communicate with the outside world. Even a large supercomputers are unable to perform any meaningful work without some method of introducing new data into the systems, and another to output a result. 

Naturally this applies to embedded systems as well. In fact the majority of embedded peripherals as well as these labs are directed at either capturing or sending information in and out of the system. In the first lab we introduced the GPIO as the most basic method of data transfer. In the second we used the EXTI controller to allow efficient hardware monitoring of GPIO inputs. The third lab used the capture/compare units in a timer peripheral to generate pseudo-analog signals through PWM. 

This lab introduces the fundamentals of data transfer through digital communication interfaces. These interfaces exist because information is only useful when it can be understood, therefore there must be defined ways of transmitting and interpreting it.

\subsection{Parallel vs Serial}

There are two main schemes, parallel and serial, for moving binary information across electrical connections. These two schemes are opposites of each other and are demonstrated in figure \ref{parallel_serial}. 

\subsubsection{Parallel}
Parallel interfaces transmit entire blocks of data using multiple wires, with each wire representing the state of a single binary bit. In a parallel system the transmitter sets the logical state of each wire, and the receiver samples all of the connections at a single instant. Parallel interfaces have a \textit{bit-width} which represents how many wires are in the connection, and indicates how many bits are sent at one time. Common bit-widths are powers of 2 to make converting into bytes simple. 

\subsubsection{Serial}
Serial interfaces use a single wire, and stream a block of data over time by lining up the bits behind each other. In order to properly transmit data, both the transmitter and receiver must agree on the time duration between data bits, known as the interface's \textit{bit/data rate}. A serial transmitter produces periodic transitions on the single data line corresponding to the data to be sent. The receiver samples this data line on a similar period and appends the sampled value to the end of the received data. 

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{parallel_serial}
    \caption{Comparison of parallel and serial communication.}
    \label{parallel_serial}
\end{figure}

\subsubsection{Interface Bandwidth and Limitations}
Because parallel connections move entire groups of bits at a time they have a much higher \textit{bandwidth} (throughput) than an equivalent serial connection. Some examples of high-speed parallel connections are the STM32F0's internal device busses (AHB and APB) which connect the ARM processor core to the SRAM, flash memory and other peripherals.

However, despite that equivalent-speed parallel connections have a higher bandwidth, most high-speed device interfaces such as SATA, USB and Ethernet are actually serial interconnects. The reason for this is because parallel connections are far more difficult to design and operate as the distance between the receiver and transmitter increases. With the incredibly high-speeds of today's communications, unless every wire in a connection is exactly the same length it is possible to have some bits arrive after the others. This means that unless the sampling rate of the receiver is slow enough to account for every bit in the connection, incorrect data will be captured.

Serial connections inherently don't have issues with wire-delay. Because bits are streamed one after another, any delays along the wire have a constant effect on the data and can't cause corruption. This enables serial connections to have a much higher bit rate than parallel, and possibly even a higher total bandwidth.

\subsection{Synchronous vs Asynchronous}

Regardless of whether an interface is serial or parallel, there must be be a mechanism that synchronizes when the transmitter and receiver updates or samples the connection. Similar to parallel and serial there are two methods, synchronous and asynchronous, of performing this task. These are demonstrated in figure \ref{synchronous_asynchronous}.

\subsubsection{Synchronous} 
Synchronous systems use a separate ``clock'' signal which notifies the receiver when to sample.  Often the data capture is synchronized to a transition such as rising or falling-edge. Synchronous systems are often simpler in design but require the extra clock connection.

\subsubsection{Asynchronous}
Asynchronous systems operate without a physical clock signal. Some methods of asynchronous communication encode a virtual clock within the transitions of the data while others estimate the time intervals that data should be expected to arrive. Because of the lack of a clock signal, asynchronous interconnects are typically more complex and have lower data rates than synchronous ones. 

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{synchronous_asynchronous}
    \caption{Comparison of synchronous and asynchronous serial communication.}
    \label{synchronous_asynchronous}
\end{figure}

\subsection{Connection Topologies} 
The topology of a communication interface is how the different devices (nodes) and the connections between them are arranged. Some interfaces are strictly point-to-point, which means that they connect only two devices with direct wires. Other interfaces have topologies which allow networks of devices to be connected together. Figure \ref{topologies} demonstrates a few simple topologies. 

\begin{itemize}
    \item \textbf{Daisy-Chain} -- Nodes in a daisy-chained network connect only to their adjacent neighbors. Some are designed to allow data to be passed along to its destination. 
    \item \textbf{Bus/Multi-Drop} -- All nodes on a bus share the same communication lines. This means that only a single device can be transmitting at a time, but all can receive
    \item \textbf{Star} -- All peripheral nodes communicate with a central master node.
    \item \textbf{Mesh} -- Nodes in a mesh network have arbitrary connections to each other. Some mesh networks are hierarchically ordered, others may be fully-connected.   
\end{itemize}



\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{topologies}
    \caption{Simple network topologies.}
    \label{topologies}
\end{figure}

\section{Communication Standards \& Protocols}

Aside from knowing how to connect and when to sample the inputs, communicating devices must know how to interpret signals into bits and how the patterns of bits make up data. To manage this, all interfaces are combinations of hardware standards and communication protocols. 

\subsection{Hardware Standards}	
Hardware standards define the physical and signaling characteristics of an interface.
A standard typically indicates the medium that the signals are transferred over such as conductive wires, optical, radio frequency or others. The standard defines the method that signals are interpreted into bits. This may be as simple as thresholding a voltage on a wire (single-ended), monitoring the voltage difference or current flow between a pair of wires (differential) or even a modulated waveform. 

Standards often indicate whether an interface is parallel or serial.

\subsection{Communication Protocols}
Hardware standards make it possible to convert an input signal into a collection of bits. However, protocols define the meaning of bits such that they create useful data. 

\subsubsection{Hardware Protocols}
Low level or hardware protocols define how bits are organized to form raw data. This primarily involves the rate that data is sampled and whether the interface has an explicit clock signal or is asynchronous.
Depending on the complexity of the interface, hardware protocols usually include higher-level features such as start/stop signals, error-correction, control flow, message acknowledgment, addressing, data packets and more.

\subsubsection{Software Protocols}	
At this point the communication peripheral's job is complete. Raw data can be converted into a communication signal and back on the receiving end. The last task is to interpret the raw data into useful instructions or information for the user's application.

A software protocol is a device driver that gives meaning to the binary data flowing into and out of the system. These drivers can be as simple as recognizing certain values as commands, or as complex as defining the organization of variable-length data packets.  In order to communicate, the user's application must define a software protocol. 

\subsection{Separating Interface and Protocol}
   
Some communication interfaces have clearly defined separations between the different standards, protocols, and application layers within them. 

For example, IEEE 802.3 is the base standard for wired Ethernet and contains subclasses for the different speeds and modifications that have been made over the years. Built upon these standards are low-level protocols such as MAC, LLC, and PPP. On these is built IP, and IP is the the base of UDP and TCP which are used for raw data connections on conventional computer networks. 

An example of a common software protocol used by computer networks is HTML. This format is used to move website data across the Internet, giving the browser application a known way to interpret raw data into something meaningful. 

Unfortunately, unlike Ethernet, many low-level interfaces such as those used in embedded systems are much more unclear where the boundaries are. Many of these interfaces have protocols and standards that were designed specifically for each other and are called by the same name. 
Because of this, many documents use the terms standard and protocol interchangeably. 

\section{Common Embedded Interfaces}
The STM32F072 has a generous selection of interface peripherals. These can be seen on the first page summary of the chip datasheet. These interfaces differ widely in operation, complexity, and features; however, they all are serial. 

The three most common serial communication interfaces used in embedded systems are TTL RS-232 (TTL-Serial/UART), Serial Peripheral Interface (SPI), and Inter-Integrated Circuit Bus (I2C). 

This lab teaches the basics of TTL RS-232 in the next few sections. SPI and I2C will be covered in later labs, a brief introduction is included here. 

\begin{itemize}
    \item \textbf{Serial Peripheral Interface (SPI)}
    \begin{itemize}
        \item SPI is a synchronous interface typically used for high-speed connections between microcontrollers and external memories or other fast-data devices.
        \item It is a full-duplex interface, which means that both sides transmit and receive at the same time.
    \end{itemize}
    \item \textbf{Inter-Integrated Circuit Bus (I2C)}
    \begin{itemize}
        \item I2C is a low(er) speed synchronous interface designed to allow multiple master devices to share the same set of signal wires. 
        \item It was primarily designed for low-speed sensors, but newer standards have increased the speed where it is also used for other purposes.
    \end{itemize}
\end{itemize}


\section{Introducing RS-232}
\subsection{Conventional RS-232}
RS-232 was first introduced in 1962 by the Electronic Industries Alliance as a method of connecting teletype terminals to a central computer. It is a point-to-point, asynchronous, full-duplex (simultaneous bi-directional communication) interface with hardware flow control signals. 

Despite changing its voltage levels and connectors over the years, RS-232 became the standard method of interconnection between computers and accessories until it began to be replaced in the late 1980's by PS2 and later USB. Because of its long and common use, RS-232 is often referred to simply as ``Serial.'' 

RS-232 carries a number of features originally designed for slow dial-up connections. The flow control signals allow the transmitter and receiver to directly notify each other that they are ready with new data or that they need a pause to process what has been transmitted. To ensure that the data signal was able to be read across a potentially long cable, RS-232 uses a wide voltage swing with positive voltages representing a `1' and negative voltages for a `0.' Although the standard allows up to {\textpm}25V many devices use between {\textpm}12V and {\textpm}15V.

The most recent and common connector used for RS-232 is the 9-pin trapezoidal DE-9 (often mistakenly called DB-9). Figure \ref{db9_pinout} shows a representation and pinout of the connector. While most consumer equipment does not feature a physical serial port anymore, RS-232 is still commonly used for equipment control within science and industry. 


\begin{figure}[]
    \centering\includegraphics[width=0.3\textwidth]{db9_pinout}
    \caption{Conventional DE9 serial connector and pinout.}
    \label{db9_pinout}
\end{figure} 

\subsection{Embedded TTL RS-232 (TTL-Serial)}
Unlike the original legacy hardware, many embedded systems run at a far lower voltages than the  RS-232 {\textpm}25V specification. Additionally, many of these systems can't generate or tolerate negative voltages. Because of this, most systems use a variant of RS-232 called TTL Serial.

TTL Serial is the same protocol as RS-232 but uses a more reasonable voltage range for signaling. Depending on the power supply that the embedded system operates from, TTL Serial often has a voltage range between 0V and 1.8V to 5V. 

Figure \ref{serial_detail} shows a detailed look into a RS-232 and TTL Serial data frame (packet). As shown, a TTL Serial signal not only has a smaller voltage range, but the waveform is also inverted. 

\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{serial_detail}
    \caption{RS-232 and TTL-Serial logic levels and polarity.}
    \label{serial_detail}
\end{figure}

RS-232 is a very flexible protocol in that many of the communication parameters are adjustable by the user. These next few sections discuss important characteristics of a RS-232 frame.  

\subsubsection{Baud Rate} 
Because RS-232 is asynchronous, both the transmitter and receiver are required to operate on a pre-agreed period between bits. This frequency is known as the \textit{Baud Rate} and represents the number of bits per second that is transmitted. 

RS-232 has no checking mechanism to ensure that both devices are tuned to the same Baud. This means that it is possible to receive corrupt data if the baud settings are not configured properly. 

In figure \ref{serial_detail} the bit periods are indicated by alternating white and gray shading. 
 
\subsubsection{Start and Stop Bits}
Although the official RS-232 protocol doesn't have a mechanism to detect the receiving Baud rate, it does include \textit{framing bits} which alert the hardware about newly arriving data. 

The first signal transition in figure \ref{serial_detail} is the \textit{start bit} of a data frame. The start bit is used to signal a new data frame and synchronize the clock of the receiver to the transmitter.   

The last transition is the \textit{stop bit} which serves as a spacer to give a minimum delay time before the next bit can start. Originally this was designed to allow the mechanical hardware in the teletype machines to move to the next position in the document.

The number of start and stop bits within a data frame is configurable. Many serial peripherals allow the user to select the number of framing bits. However, similar to the baud rate, both devices need to agree to interpret the data correctly. 

\subsubsection{Data Bits} 
Typically each frame in RS-232 contains a single data byte. Although uncommon, the standard allows non-byte data sizes between 5 and 9 bits. The baud rate of the signal includes the framing bits within its calculation of total bits per second. This means that the actual useful data transmitted is always less than the theoretical throughput indicated by the baud. 

\subsubsection{Parity \& Error Checking}
Most hardware peripherals support appending a \textit{parity} bit to the end of the data. Parity is a method of error checking, where the parity bit is set such that the number of `1' bits in each data frame is always even or odd. If the number of received `1' bits fails to match the expected parity, then the hardware can determine that the transmission has been corrupted. 

Parity can only determine if as single bit in the data has been corrupted, it doesn't provide for any error correction and can fail if an even number of bits are corrupt. Parity isn't used very often anymore because of this limitation. Many devices contain hardware for performing more sophisticated \textit{cyclic redundancy checks} (CRC).  

%\subsubsection{USB-UART Cables}
%Because it is unlikely that consumer computers have native TTL Serial interfaces, many chip vendors sell devices that act as a protocol bridge between USB and TTL Serial. These are built into cables or small circuit boards and often called USB-Serial or USB-UART converters. 
%
%Although these devices are almost universal, this lab suggests using the Adafruit 954 USB-UART cable. This cable directly connects to the USB port of a desktop computer and outputs 3.3V TTL Serial on a 4-pin wire connector. 

\subsection{ASCII Text Encoding}
Old standard for text exchange based on 8-bit characters
Has 128 characters in 7-bits, the last bit is used for parity
Some characters have system meanings such as a newline char
others are non-printing
Some system chars no longer have much meaning in modern systems
Was extended to use all 8-bits 
The original ASCII has since been expanded into the Unicode character standard
Many different encodings for unicode such as UTF8
Will be using base ASCII for embedded communication	
\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{ascii_table}
    \caption{Subset of the ASCII text encoding standard.}
    \label{ascii_table}
\end{figure}

\section{Introducing the USART}
What the USART is and why it has its name
Typically used for TTL RS-232
Modes of operation
mainly to mention that it has other modes, but we won't discuss them 
\subsection{USART Registers}	
Overview of all registers used for RS-232
Give short description and what each register does (what settings it manages)
Mention other registers and indicate that they won't need them
\subsection{Configuring the Baud Rate}	
Configuring the BAUD rate registers
Basic equations of calculating baud rate
How to load into the mantissa and fractional baud registers
\subsection{Blocking vs Non-blocking Operation}
mainly mention that you can use buffers and interrupts to make code that doesn't wait around until transmission is complete. 
mention why it's bad to wait sometimes
won't be doing non-blocking drivers in this lab (later lab perhaps?)
\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{blocking_nonblocking}
    \caption{Blocking and non-blocking drivers.}
    \label{blocking_nonblocking}
\end{figure}
\subsection{Performing Basic Transmits and Receives}
Give flowcharts for blocking receive and transmit
\begin{figure}[]
    \centering\includegraphics[width=\textwidth]{blocking_flowchart}
    \caption{Flowchart for simple RX/TX communications on the USART.}
    \label{blocking_flowchart}
\end{figure}
Explicitly say when they need to wait/check a flag for this condition before moving onward. 
Don't give actual bit names, but they should be able to use the register descriptions to know where to look
Give pretty obvious hints as to what they should look for when searching for bits.
\subsubsection{Text Formatting}
No printf yet... need to build own string transmit, string compare and eventually numeric value to ASCII character functions
Kiel provides a miniature version of the c standard library called microlib
Can configure and use printf with our USART, but won't in this lab. (later labs?)

\section{Using a USB-UART Cable and the Terminal}
\subsection{The USB-UART Cable}
Using the USB-USART cable and Putty Terminal program
Using and connecting the cable

\begin{figure}[]
    \centering\includegraphics[width=0.6\textwidth]{usb_uart}
    \caption{Pinout of the Adafruit 954 USB-UART cable.}
    \label{usb_uart}
\end{figure}

\subsection{Finding Installed Ports on Windows}
Where to find on windows
windows calls "COM\#" located in device manager
need steps to find on lab machines.




\subsection{Using the Putty Terminal Program}
How to set up Putty

\begin{figure}[]
    \centering\includegraphics[height=0.45\textheight]{device_manager}
    \caption{Windows device manager with the ports tab expanded.}
    \label{device_manager}
\end{figure}
\begin{figure}[]
    \centering\includegraphics[height=0.40\textheight]{putty}
    \caption{Putty serial terminal}
    \label{putty}
\end{figure}
mention typing in terminal, no response
how to test cable/terminal with loopback (wire between RX/TX)

%\section{Lab Assignment}
%\subsection{Preparing to use the USART} 
%Set up pins and connect USB-USART cable
%Have them test terminal/cable with loopback
%Provided code (HAL library?) to enable and test USART, should see string printed in terminal
%\subsection{Blocking Transmission}	
%Set up and enable USART to baud rate using registers
%Transmit single char in loop to terminal
%Write simple string transmit function and send strings to terminal 
%mention C-strings, but tell them to look elsewhere for help with those
%Capture and decode the string using the logic analyzer
%include screenshot in lab report
%\subsection{Blocking Reception}			
%Receive single chars in loop from terminal
%toggle LEDs on char match (r for red etc...)
%\subsection{Interrupt-Based Reception and Command Parsing}	
%Set up USART RX interrupt
%set up static buffer (with basic over/underflow protection)
%buffer word until newline and set flag
%Use simple state machine and string match (they can write) in main program to recognize simple command strings (example: "red \\n on \\n")
%Provide text feedback "ready for command", "buffer overflow", "unknown command", "invalid command", "command accepted"
%\begin{figure}[]
%    \centering\includegraphics[width=\textwidth]{command_flowchart}
%    \caption{Flowchart for command parsing.}
%    \label{command_flowchart}
%\end{figure}


\end{document}
